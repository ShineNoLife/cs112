normalCase.cpp
#include "../testlib.h"
#include "bits/stdc++.h"
using namespace std;

const int N_MIN = 2;
const int N_MAX = 1000;
const int C_MIN = 1;
const int C_MAX = 100;

int main(int argc, char **argv) {
    registerGen(argc, argv, 1);
    int type = atoi(argv[1]);
    long long seed = atoll(argv[2]);
    int sub = atoll(argv[3]);
    rnd.setSeed(seed);

    int n = -1, m = -1;
    if(sub == 1) {
        n = 10;
        m = 20;
    } else if(sub == 2) {
        n = rnd.next(5, N_MAX);
        m = rnd.next(n-1, min(n*(n-1), 20000));
    } else {
        n = rnd.next(100000-10, 100000);
        m = rnd.next(1ll*n-1, min(1ll*n*(n-1), 20000ll));
    }
    cout << n << " " << m << "\n";

    // thêm cạnh ngẫu nhiên
    for (int i = n; i <= m; ++i) {
        int u = rnd.next(1, n);
        int v = rnd.next(1, n);
        int w = rnd.next(C_MIN, C_MAX);
        cout << u << " " << v << " " << w << "\n";
    }
}
specialCase.cpp
#include "../testlib.h"
#include "bits/stdc++.h"
using namespace std;

int main(int argc, char **argv) {
    registerGen(argc, argv, 1);
    int type = atoi(argv[1]);
    long long seed = atoll(argv[2]);
    rnd.setSeed(seed);

    vector<tuple<int,int,int>> e;
    int n=0;

    if(type==1){ // cycle có hướng
        n=6;
        for(int i=1;i<=n;i++) e.push_back({i,(i%n)+1,1});
    }
    else if(type==2){ // hai đường cùng độ dài
        n=6;
        e.push_back({1,2,1});
        e.push_back({2,6,1});
        e.push_back({1,3,1});
        e.push_back({3,6,1});
    }
    else if(type==3){ // đồ thị dày nhưng tồn tại nhiều song song
        n=10;
        for(int i=0;i<200;i++) e.push_back({rnd.next(1,n),rnd.next(1,n),rnd.next(1,100)});
    }
    else if(type==4){ // dense complete nhưng chưa tới TLE
        n=400;
        for(int i=1;i<=n;i++) for(int j=1;j<=n;j++) if(i!=j)
            e.push_back({i,j,1});
    }
    else if(type==5){ // reverse only (không tới n)
        n=50;
        for(int i=2;i<=n;i++)
            e.push_back({i,i-1,1});
    } else if(type == 6) {
        n=5;
        e.push_back({1,2,1});
        e.push_back({2,3,1});
        e.push_back({3,4,1});
        e.push_back({4,5,1});
        e.push_back({5,1,1}); // tạo chu trình
    }

    cout<<n<<" "<<e.size()<<"\n";
    for(auto [u,v,w]:e) cout<<u<<" "<<v<<" "<<w<<"\n";
}
p1.txt
stressCase.cpp
#include "../testlib.h"
#include "bits/stdc++.h"
using namespace std;

const int N_MAX = 100000;
const int M_MAX = 200000;
const int C_MAX = 1000000000;

int main(int argc, char **argv) {
    registerGen(argc, argv, 1);
    int type = atoi(argv[1]);
    long long seed = atoll(argv[2]);
    int sub = atoll(argv[3]);
    
    rnd.setSeed(seed);

    int n = -1, m = -1;
    if(sub == 1) {
        n = 10;
        m = 20;
    } else if(sub == 2) {
        n = 1000;
        m = rnd.next(n-1, min(n*(n-1), 20000));
    } else {
        if(rnd.next(0, 1)) {
            n = N_MAX;
            m = M_MAX;
        } else {
            n = 3000;
            vector<pair<int,int>> all;
            for(int i=1;i<=n;i++)
                for(int j=i;j<=n && all.size()<M_MAX;j++)
                    all.push_back({i,j});
            m = all.size();
            cout<<n<<" "<<m<<"\n";
            for(auto [u,v]:all)
                cout<<u<<" "<<v<<" "<<rnd.next(C_MAX-100,C_MAX)<<"\n";
            return 0;
        }
    }
    cout << n << " " << m << "\n";

    for (int i = 0; i < m; ++i) {
        int u = rnd.next(1, n);
        int v = rnd.next(1, n);
        long long w = rnd.next(C_MAX-10, C_MAX);
        cout << u << " " << v << " " << w << "\n";
    }
}
print.py
import os


for file in os.listdir():
    os.system(f"echo {file}")
    os.system(f"cat {file}")edgeCase.cpp
#include "../testlib.h"
#include "bits/stdc++.h"
using namespace std;

const int N_MAX = 10;
const long long BIG = 3000000000LL; // gây tràn int
const int C_MAX = 1000000000;

int main(int argc, char **argv) {
    registerGen(argc, argv, 1);
    int type = atoi(argv[1]);
    long long seed = atoll(argv[2]);
    rnd.setSeed(seed);

    int n, m;
    vector<tuple<int,int,long long>> edges;

    switch (type) {
        case 1: { // tràn int trên cạnh
            n = 3; m = 2;
            edges.push_back({1,2,BIG});
            edges.push_back({2,3,BIG});
            break;
        }
        case 2: { // sử dụng mảng [1..n]
            n = 5; m = 6;
            for (int i=1;i<=m;i++)
                edges.push_back({rnd.next(1,n),rnd.next(1,n),rnd.next(1,10)});
            break;
        }
        case 3: { // đồ thị có hướng, chỉ đi ngược
            n = 5; m = 4;
            for (int i=2;i<=n;i++)
                edges.push_back({i,i-1,rnd.next(1,100)});
            break;
        }
        case 4: { // đồ thị đa cạnh
            n = 4; m = 8;
            for (int i=0;i<m;i++)
                edges.push_back({1,2,rnd.next(1,10)});
            break;
        }
        case 5: { // không có đường đi (-1 case nhỏ)
            n = 5; m = 3;
            for (int i=0;i<m;i++)
                edges.push_back({rnd.next(3,5),rnd.next(3,5),rnd.next(1,50)});
            break;
        }
        case 6: { // multiple edges causing overwrite in naive adjacency matrix
            n = 4; m = 6;
            edges.push_back({1,2,5});
            edges.push_back({1,2,10}); // ghi đè
            edges.push_back({2,3,7});
            edges.push_back({2,3,3});
            edges.push_back({3,4,1});
            edges.push_back({3,4,2});
            break;
        }
        case 7: { // sum overflow nếu dùng int
            n = 3; m = 3;
            edges.push_back({1,2,2000000000});
            edges.push_back({2,3,2000000000});
            edges.push_back({3,1,2000000000});
            break;
        }
        case 8: { // đồ thị có hướng, code quên xử lý sẽ WA
            n = 5; m = 5;
            edges.push_back({1,2,1});
            edges.push_back({2,3,1});
            edges.push_back({3,4,1});
            edges.push_back({4,5,1});
            edges.push_back({5,1,1});
            break;
        }
        case 9: { // có đường đi (OK, nhỏ)
            n = 6;
            edges.push_back({1,2,3});
            edges.push_back({2,3,2});
            edges.push_back({3,4,1});
            edges.push_back({4,5,5});
            edges.push_back({5,6,2});
            break;
        }
        case 10: { // không có đường đi, lớn
            n = 1000; m = 200;
            for(int i=0;i<m;i++)
                edges.push_back({rnd.next(500,1000), rnd.next(500,1000), rnd.next(1,100)});
            break;
        }
        case 11: { // có đường đi, lớn, để test TLE nhẹ
            n = 1000;
            for(int i=1;i<n;i++)
                edges.push_back({i,i+1,rnd.next(1,100)});
            break;
        }
    }

    cout << n << " " << edges.size() << "\n";
    for (auto &e : edges) {
        int u,v; long long w;
        tie(u,v,w)=e;
        cout<<u<<" "<<v<<" "<<w<<"\n";
    }
}
